package sourceanalysis.dox;

import java.io.File;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.w3c.dom.Document;
import sourceanalysis.*;

/**
 * The Document/Component Registry 
 */
public class DocumentComponentRegistry {

	/**
	 * Stores a pair of locators:
	 * <ol>
	 *  <li>Document name (XML filename without the <tt>.xml</tt> extension)
	 *  </li>
	 *  <li>Component ID which is unique to this document</li>
	 * </ol>
	 */
	public static class EntityLocator
	{
		/**
		 * Initializes the locator.
		 * @param kind type of entity being referenced
		 * @param document document name
		 * @param component_id component ID (unique within document)
		 */
		public EntityLocator(String kind, String document, String component_id)
		{
			m_kind = kind;
			m_document = document;
			m_component_id = component_id;
		}
		
		/**
		 * Initializes the locator from a reference string in the format that 
		 * appears in &lt;ref&gt; nodes.
		 * @param kind type of entity being referenced
		 * @param component_id a combination of the document name and the
		 * component ID. Normally this is just the component ID alone, since
		 * it contains the name of the document anyway.
		 */
		public EntityLocator(String kind, String component_id)
		{
			m_kind = kind;
			m_component_id = component_id;
			
			Matcher separator = m_id_cap_pattern.matcher(component_id);
			// If the separator exists, the document name is taken to be the
			// portion of the id left to the separator. Otherwise, the id and
			// the document name are identical.
			if (separator.find())
				m_document = component_id.substring(0, separator.start());
			else
				m_document = component_id;
		}
		
		/**
		 * Returns the referenced entity's kind.
		 * @return String kind string
		 */
		public String getKind() { return m_kind; }
		
		/**
		 * Returns the document-id portion of the locator.
		 * @return String a document name
		 */
		public String getDocumentName() { return m_document; }
	
		/**
		 * Returns the component-id portion of the locator.
		 * @return String the component identifying string
		 */
		public String getComponentID() { return m_component_id; }
		
		/**
		 * Forms a string from the document name and component-id which is
		 * unique database-wide.
		 * @return String text of the form: <i>document</i><tt>_</tt><i>id</i>
		 */
		public String unique()
		{
			// ID is enough under the current implementation of Doxygen's
			// XML generation module
			return m_component_id;
		}

		private String m_kind;		
		private String m_document;
		private String m_component_id;
	
		private static Pattern m_id_cap_pattern = Pattern.compile("_1[a-f0-9]+$");
	}

	/**
	 * DocumentComponentRegistry constructor.
	 * <p>Prepares an empty registry for activity. </p>
	 */
	public DocumentComponentRegistry()
	{
		m_id2entity = new HashMap();
		m_docname2dom = new HashMap();
		m_deferred = new HashSet();
		m_xmldir = "xml/";
		// Get the alternative XML path from griffin.dox.path
		String path = System.getProperty(XML_ALTERNATIVE_PATH_PROPERTY);
		if (path != null)
			m_xmlpath = (m_xmldir + ":" + path).split(":");
		else
			m_xmlpath = new String[] { m_xmldir };
	}

	/**
	 * Sets the location where XML files generated by Doxygen(r) are placed.
	 * @param xmldir a relative or an absolute path to the directory
	 * containing .xml files (in particular, <tt>index.xml</tt>).
	 */
	public void setInputDirectory(String xmldir)
	{
		if (xmldir.charAt(xmldir.length()-1) == '/')
			m_xmldir = xmldir;
		else
			m_xmldir = xmldir + "/";
		m_xmlpath[0] = m_xmldir;
	}

	/**
	 * @name Registration API
	 * Methods for writing data into the registry.
	 */
	/*@{*/
	
	/**
	 * Registers an entity by its <tt>document_component-id</tt> as well as
	 * by name.
	 * @param entity the entity being subscribed
	 * @param id an identifying pair of document and component id.
	 */
	public void subscribe(Entity entity, EntityLocator id)
	{
		m_id2entity.put(id.unique(), entity);
	}
	
	/*@}*/

	/**
	 * @name Retrieve API
	 * Methods for searching entities by IDs.
	 */
	/*@{*/

	/**
	 * Finds an entity by its locator id.
	 * @param id a pair of document name and component id within document
	 * @return Entity the entity from the registry
	 * @throws ElementNotFoundException if the entity is not subscribed in
	 * the registry.
	 */	
	public Entity locate(EntityLocator id) throws ElementNotFoundException
	{
		// Search in previous subscriptions
		Object entity = m_id2entity.get(id.unique());
		if (entity != null) {
			return (Entity)entity;
		}
		else {
			throw new ElementNotFoundException("referenced entity", id.unique());
		}
	}

	/**
	 * Finds an XML document. If the document has been read and stored,
	 * returns stored document, otherwise - it fetches the document anew.
	 * @param documentname name of XML document
	 * @return Document DOM document
	 * @throws ElementNotFoundException the document is not in the registry,
	 * and also there exists no document by that name in the input directory.
	 */
	public Document locateDocument(String documentname)
		throws ElementNotFoundException
	{
		// Check that object was not previously deferred
		if (m_deferred.contains(documentname))
			throw new ElementNotFoundException("document", documentname);
		// Try getting object from registry
		Object document = m_docname2dom.get(documentname);
		if (document != null) {
			return (Document)document;
		}
		else {
			// Fetch from input directory (exception may occur here)
			Document anew = fetch(documentname);
			m_docname2dom.put(documentname, anew);
			return anew;
		}
	}

	/**
	 * Reads XML using a DOM parser.
	 * @return Document the XML document as a DOM tree
	 */
	private Document fetch(String documentname) 
		throws ElementNotFoundException
	{
		// Find document in XML search path
		File documentfile = searchInPath(documentname + ".xml");
		// Open and parse XML
		org.apache.xerces.parsers.DOMParser p = new org.apache.xerces.parsers.DOMParser();
		try {
			p.parse(documentfile.toString());
		}
		catch (java.io.IOException e) {
			m_deferred.add(documentname);
			throw new ElementNotFoundException("document", documentname);
		}
		catch (org.xml.sax.SAXException e) { 
			m_deferred.add(documentname);
			throw new ElementNotFoundException("document", documentname); 
		}
		return p.getDocument();
	}
	
	/**
	 * Looks for a document in the XML search path. The path is taken
	 * from the system properties when the DocumentComponentRegistry is
	 * first created.
	 * @param filename the name of the file to be searched
	 * @return A File referring to an existing file with the requested
	 * basename and which resides in one of the directories sought.
	 * The m_xmldir is sought last, when previous search fails.
	 */
	private File searchInPath(String filename)
	{
		// - search for filename in all the directories in path
		for (int i = 0; i < m_xmlpath.length; i++) {
			File directory = new File(m_xmlpath[i]);
			if (directory.exists() && directory.isDirectory()) {
				File file = new File(directory, filename);
				if (file.exists() && file.isFile())
					return file;
			}
		}
		// - fallback to xmldir
		return new File(new File(m_xmldir), filename);
	}
	
	/*@}*/

	// Private
	private Map m_id2entity;
	private Map m_docname2dom;
	private Set m_deferred;  // XML documents which contained errors
	
	private String m_xmldir;
	private String m_xmlpath[];
	
	private static final String XML_ALTERNATIVE_PATH_PROPERTY
		= "griffin.dox.path";
}
