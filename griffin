#!/usr/bin/env python
"""Griffin launcher script."""

import os.path, sys, re, griffin as conf

here = os.path.dirname(__file__)

class Griffin:

    premises = ["jython.jar", "antlr.jar", "xercesImpl.jar", \
                "junit.jar", "xmlParserAPIs.jar"]
    premisedir = "premises"
    jardir = os.path.join(here, premisedir)
    if not os.path.isdir(jardir): jardir = "/usr/share/java"
    robindir = "/usr/share/robin"

    DEFAULT_OUTFILE = "./4robin.cc"
    GRIFFIN_JAR = "Griffin.jar"


    def __init__(self):
        self.griffin_bin = os.path.join(here, self.GRIFFIN_JAR)
        if not os.path.isfile(self.griffin_bin):
          self.griffin_bin = os.path.join(self.jardir, self.GRIFFIN_JAR)
        self.javacmd = "backend.Launcher robin"
        self.javaflags = ""
        self.module = "."
        self.verbose = False

    def setXML(self, xmldir):
        if not os.path.isdir(xmldir):
            raise OSError, "'%s' not found" % xmldir
        self.xmldir = xmldir

    def setSources(self, sources, modules):
        self.doxygen(self.module, sources, modules)
        self.xmldir = os.path.join(self.module, "xml")

    def doxygen(self, project, sources, modules):
        import os.path
        stltag = os.path.join(here, "build/stl.tag")
        if not os.path.isfile(stltag): stltag = os.path.join(here, "stl.tag")
        if not os.path.isfile(stltag): stltag = os.path.join(self.robindir, "stl.tag")
        tagfiles = [stltag] + [os.path.join(x, "module.tag") for x in modules]
        tagfile = os.path.join(project, "module.tag")
        doxyfile = "INPUT = %s\nGENERATE_XML=Yes\nEXTRACT_ALL=Yes\n" \
                   "OUTPUT_DIRECTORY = %s\nTAGFILES = %s\n" \
                   "GENERATE_TAGFILE = %s\n" \
                   "GENERATE_HTML=No\nGENERATE_LATEX=No\n" \
                   "ENABLE_PREPROCESSING=Yes\nMACRO_EXPANSION=Yes\n" \
                   "SEARCH_INCLUDES=Yes\nINCLUDE_PATH=/usr/include" % \
                   (" ".join(sources), project, " ".join(tagfiles), tagfile)

        if self.verbose: print ".griffin-doxyfile:\n" + doxyfile
        open(".griffin-doxyfile", "w").write(doxyfile)
        Dots(self.verbose).run("doxygen .griffin-doxyfile")
        if self.verbose: print "unlink .griffin-doxyfile"
        os.unlink(".griffin-doxyfile")

    def _command(self, modules):
        from os.path import join
        classpath = [join(self.jardir, x) for x in self.premises]
        classpath += [self.griffin_bin]

        doxpath = join(here, "build/dox-xml")
        stpath = join(here, "src/griffin/modules/stl")
        if not os.path.isdir(doxpath): doxpath = os.path.join(here, "dox-xml")
        if not os.path.isdir(doxpath): doxpath = join(self.robindir, "dox-xml")
        if not os.path.isdir(stpath): stpath = here
        if not os.path.isdir(stpath): stpath = self.robindir
        doxpath = [doxpath] + [os.path.join(x, "xml") for x in modules]
        stpath = [stpath]

        cmd = '%s -Dgriffin.dox.path="%s" -Dgriffin.st.path="%s" ' \
                  '-classpath "%s" %s %s' % \
                  (conf.config.java, conf.classpath(doxpath), 
                   conf.classpath(stpath), conf.classpath(classpath),
                   self.javaflags, self.javacmd)
        return cmd

    def run(self, args, modules):
        cmdline = " ".join([self._command(modules),
                            "--input", self.xmldir] + args)
        if self.verbose: print >> sys.stderr, cmdline
        os.system(cmdline)

    def _opt_eclipse(self):
        self.griffin_bin = os.path.join(here, "build/eclipse-bin")

    def _argv(self, args):
        """Parse command-line arguments."""
        from robinlib import argparse

        parser = argparse.ArgumentParser("griffin",
            description="Griffin - wrapper code generator for Robin.")
        parser.add_argument(
            "--in", metavar="filename", type=str, nargs="+", default=[],
            help="either list of input source filenames, or XML directory "
            "previously generated by doxygen")
        parser.add_argument(
            "--out", metavar="filename", type=str,
            default=self.DEFAULT_OUTFILE,
            help="generated output file (default: %s)" % self.DEFAULT_OUTFILE)
        parser.add_argument(
            "inputs", metavar="identifier", type=str, nargs="*",
            help="source files, classes, and functions to be wrapped")
        parser.add_argument(
            "--classes", metavar="identifier", type=str, nargs="+", default=[],
            help="classes and functions to be wrapped")
        parser.add_argument(
            "--module", metavar="module-name",
            help="name for the generated module (generates doxygen tag file"
            " and xml output directory for use in later projects)")
        parser.add_argument(
            "--import", metavar="path", type=str, nargs="+", default=[],
            help="doxygen output directory of external modules to refer to")
        parser.add_argument(
            "-I", action='store_true', default=False,
            help="process #included header files recursively")
        parser.add_argument(
            "--interceptors", action='store_true', default=False,
            help="also generate interceptor classes for wrapped interfaces")
        parser.add_argument(
            "--hints", type=str, metavar="jython-hints",
            help="specify a Jython file containing code generation hints")
        parser.add_argument(
            "-v", action='store_true', default=False,
            help="be verbose")
        parser.add_argument(
            "--eclipse", action='store_true', default=False,
            help="(development) use Griffin as compiled by Eclipse "
            "instead of Griffin.jar")
        parser.add_argument(
            "--debug", metavar="port", type=int,
            help="(development) launch JVM in debug mode")

        if not args: args = ["-h"]

        values = parser.parse_args(args)
        FLAGS = ["I", "v", "debug", "interceptors", "module"]
        OPTS = ["hints", "import"]
        arg_in = values.__dict__['in']
        arg_out = values.out
        arg_classes = values.classes
        arg_opts = dict([(x,y) for (x,y) in values.__dict__.items()
                         if (y and x in FLAGS) or x in OPTS])

        if values.inputs:
            arg_in += [x for x in values.inputs if "." in x]
            arg_classes += [x for x in values.inputs if "." not in x]
        if values.eclipse:
            self._opt_eclipse()
        return arg_in, [arg_out], arg_opts, arg_classes

    def jarg(self, name, value):
        """
        Encodes an argument for the Java application.
        """
        if isinstance(value, str):
            return "--%s=%s" % (name, value)
        else:
            return "--%s" % name

    def process(self, args):
        """Runs Griffin front-end and back-end using the given arguments."""
        arg_in, arg_out, arg_opts, arg_other = self._argv(args)
        arg_out = ["--outfile"] + arg_out
        arg_other = ["--classes"] + arg_other

        if len(arg_in) > 0:
            if arg_in[0] in ["xml", "sources"]:
                input_type = arg_in[0]
                arg_in = arg_in[1:]
            else:
                # - try to intelligently guess input type
                import os.path
                if os.path.isfile(arg_in[0]):
                    input_type = "sources"
                else:
                    input_type = "xml"
        else:
            input_type = "none"

        self.verbose = "v" in arg_opts
        wizard = "w" in arg_opts or "wizard" in arg_opts

        imported = arg_opts["import"]
        if "module" in arg_opts: self.module = arg_opts["module"]

        # Set input source
        if input_type == "sources":
            if "I" in arg_opts:
                arg_in = Preprocessor().extractAllIncluded(arg_in)
            self.setSources(arg_in, imported)
        elif input_type == "xml" or wizard:
            if len(arg_in) == 0:
                self.setXML("xml")
            else:
                self.setXML(arg_in[0])
        else:
            print "griffin: No input specified. Quit."
            raise SystemExit

        JOPTS = ["interceptors", "hints"]
        arg_jopts = [self.jarg(x,y) for (x,y) in arg_opts.items()
                     if x in JOPTS]

        if "debug" in arg_opts:
            self.javaflags = "-Xrunjdwp:transport=dt_socket,address=%d,server=y,suspend=y" % arg_opts["debug"]

        if wizard:
            self.javacmd = "wizard.Main"
            self.premises.extend(["swt.jar","jface.jar", 
                                  "org.eclipse.core.runtime.jar"])

        # engage
        self.run(arg_out + arg_jopts + arg_other, imported)



class Preprocessor(object):

    INCLUDE_DIRECTIVE = re.compile(r'^\s*#\s*include\s*"(.*)"')

    def findHeader(self, included_in, included):
        rel = os.path.join(included_in, os.path.pardir, included)
        return os.path.normpath(rel)

    def extractIncluded(self, filename):
        if not os.path.isfile(filename): return []
        # Look for 'include' directives
        all_included = []
        for line in open(filename):
            mo = Preprocessor.INCLUDE_DIRECTIVE.search(line)
            if mo:
                included = self.findHeader(filename, mo.group(1))
                if included:
                    all_included.append(included)
        return all_included

    def extractAllIncluded(self, filenames):
        filenames = map(os.path.normpath, filenames)
        i = 0
        while i < len(filenames):
            for included in self.extractIncluded(filenames[i]):
                if included not in filenames and os.path.isfile(included):
                    filenames.append(included)
            i += 1
        return filenames


class CommandRunner(object):
    def __init__(self, verbose = False):
        self.verbose = verbose
        
    def run(self, command):
        pass

class ShellRunner(CommandRunner):
    def run(self, command):
        if self.verbose: print command
        os.system(command)

class Dots(CommandRunner):
    """Runs an external command without sending all the output to the tty."""
    def run(self, command):
        if self.verbose: print command
        pipe = os.popen(command)
        for line in pipe:
            sys.stderr.write(".")
        if pipe.close():
            sys.stderr.write(" [FAILED]\n")
            raise OSError, "failed to run " + command.split()[0]
        else:
            sys.stderr.write(" [  OK  ]\n")


if __name__ == "__main__":
    g = Griffin()
    try:
        g.process(sys.argv[1:])
    except OSError, msg:
        print "griffin:", msg
