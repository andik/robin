#!/usr/bin/env python
"""Griffin launcher script."""

import os.path, sys, re, griffin as conf


class Griffin:

	premises = ["jython.jar", "antlr-2.7.5.jar", "xercesImpl.jar", \
	            "junit.jar", "xmlParserAPIs.jar"]
	premisedir = "premises"

	DEFAULT_OUTFILE = "./4robin.cc"
	GRIFFIN_JAR = "Griffin.jar"


	def __init__(self):
		self.griffin_bin = os.path.join(here, self.GRIFFIN_JAR)
		self.javacmd = "backend.robin.Launcher"
		self.javaflags = ""
		self.verbose = False

	def setXML(self, xmldir):
		if not os.path.isdir(xmldir):
			raise OSError, "'%s' not found" % xmldir
		self.xmldir = xmldir

	def setSources(self, sources):
		self.doxygen(sources)
		self.xmldir = "./xml"

	def doxygen(self, sources):
		import os.path
		stltag = os.path.join(here, "build/stl.tag")
		if not os.path.isfile(stltag): stltag = os.path.join(here, "stl.tag")
		doxyfile = "INPUT = %s\nGENERATE_XML=Yes\nEXTRACT_ALL=Yes\n" \
		           "TAGFILES = %s\n" \
		           "GENERATE_HTML=No\nGENERATE_LATEX=No\n" % \
		             (" ".join(sources), stltag)
		if self.verbose: print ".griffin-doxyfile:\n" + doxyfile
		open(".griffin-doxyfile", "w").write(doxyfile)
		Dots(self.verbose).run("doxygen .griffin-doxyfile")
		if self.verbose: print "unlink .griffin-doxyfile"
		os.unlink(".griffin-doxyfile")

	def _command(self):
		from os.path import join
		classpath = [join(here, self.premisedir, x) for x in self.premises]
		classpath += [self.griffin_bin]

		doxpath = join(here, "build/dox-xml")
		stpath = join(here, "src/griffin/modules/stl")
		if not os.path.isdir(doxpath): doxpath = os.path.join(here, "dox-xml")
		if not os.path.isdir(stpath): stpath = here

		cmd = "%s -Dgriffin.dox.path='%s' -Dgriffin.st.path='%s' " \
		          "-classpath '%s' %s %s" % \
		          (conf.config.java, conf.classpath([doxpath]), 
		           conf.classpath([stpath]), conf.classpath(classpath),
		           self.javaflags, self.javacmd)
		return cmd

	def run(self, args):
		cmdline = " ".join([self._command(), self.xmldir] + args)
		if self.verbose: print >> sys.stderr, cmdline
		os.system(cmdline)

	def _opt_eclipse(self):
		self.griffin_bin = os.path.join(here, "build/eclipse-bin")

	def _argv(self, args):
		"""Parse command-line arguments."""
		arg_in = []
		arg_out = []
		arg_opts = {}
		arg_other = []
		read_to = arg_other; read_limit = 0
		for arg in args:
			if arg == "-in":
				read_to = arg_in; read_limit = 0
			elif arg == "-out":
				read_to = arg_out; read_limit = 1
			elif arg == "-eclipse":
				self._opt_eclipse()
			elif arg == "-debug":
				read_to = arg_opts[arg] = []; read_limit = 1
			elif arg in ["-I", "-v"] or arg.startswith("--"):
				arg_opts[arg] = ""
			else:
				read_to.append(arg)
				if read_limit > 0:
					read_limit -= 1
					if read_limit == 0:
						read_to = arg_other

		if arg_other and not arg_in:
			arg_in = arg_other[0:1]
			arg_other = arg_other[1:]
		if not arg_out:
			arg_out = [self.DEFAULT_OUTFILE]

		return arg_in, arg_out, arg_opts, arg_other

	def process(self, args):
		"""Runs Griffin front-end and back-end using the given arguments."""
		arg_in, arg_out, arg_opts, arg_other = self._argv(args)

		if len(arg_in) > 0:
			if arg_in[0] in ["xml", "sources"]:
				input_type = arg_in[0]
				arg_in = arg_in[1:]
			else:
				# - try to intelligently guess input type
				import os.path
				if os.path.isfile(arg_in[0]):
					input_type = "sources"
				else:
					input_type = "xml"
		else:
			input_type = "none"

		self.verbose = "-v" in arg_opts

		# Set input source
		if input_type == "sources":
			if "-I" in arg_opts:
				arg_in = Preprocessor().extractAllIncluded(arg_in)
			self.setSources(arg_in)
		elif input_type == "xml":
			if len(arg_in) == 0:
				self.setXML("xml")
			else:
				self.setXML(arg_in[0])
		else:
			print "No input specified. Quit."
			raise SystemExit

		arg_jopts = [x for x in arg_opts.keys() if x.startswith("--")]

		if "-debug" in arg_opts:
			self.javaflags = "-Xrunjdwp:transport=dt_socket,address=1234,server=y,suspend=y"

		# engage
		self.run(arg_out + arg_jopts + arg_other)



class Preprocessor(object):

	INCLUDE_DIRECTIVE = re.compile(r'^\s*#\s*include\s*"(.*)"')

	def findHeader(self, included_in, included):
		rel = os.path.join(included_in, os.path.pardir, included)
		return os.path.normpath(rel)

	def extractIncluded(self, filename):
		if not os.path.isfile(filename): return []
		# Look for 'include' directives
		all_included = []
		for line in open(filename):
			mo = Preprocessor.INCLUDE_DIRECTIVE.search(line)
			if mo:
				included = self.findHeader(filename, mo.group(1))
				if included:
					all_included.append(included)
		return all_included

	def extractAllIncluded(self, filenames):
		filenames = map(os.path.normpath, filenames)
		i = 0
		while i < len(filenames):
			for included in self.extractIncluded(filenames[i]):
				if included not in filenames and os.path.isfile(included):
					filenames.append(included)
			i += 1
		return filenames


class CommandRunner(object):
	def __init__(self, verbose = False):
		self.verbose = verbose
		
	def run(self, command):
		pass

class ShellRunner(CommandRunner):
	def run(self, command):
		if self.verbose: print command
		os.system(command)

class Dots(CommandRunner):
	"""Runs an external command without sending all the output to the tty."""
	def run(self, command):
		if self.verbose: print command
		pipe = os.popen(command)
		for line in pipe:
			sys.stderr.write(".")
		if pipe.close():
			sys.stderr.write(" [FAILED]\n")
			raise OSError, "failed to run " + command.split()[0]
		else:
			sys.stderr.write(" [  OK  ]\n")


here = os.path.dirname(__file__)



if __name__ == "__main__":
	if sys.argv[1:]:
		g = Griffin()
		try:
			g.process(sys.argv[1:])
		except OSError, msg:
			print "griffin:", msg
	else:
		print
		print "Usage: griffin -in <input> -out <output-file> <class-names>"
		print
		print "Where:"
		print "  <input> is either 'xml <xmldir>'"
		print "                 or 'sources <source-files>' (space-delimited)"
		print "                 or '<xmldir>'"
		print "                 or '<source-files>'"
		print "          (in the last two cases griffin will intelligently"
		print "           guess the input type)"
		print "  <output-file> is a filename and defaults to './4robin.cc'"
		print "  <class-names> is a space-delimited list of classes to analyze"
		print
		print "More option flags:"
		print "  -I    process #included header files recursively"
		print "  -v    be verbose"
		print
